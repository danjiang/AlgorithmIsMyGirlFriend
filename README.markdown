## ⏳ 复杂度分析

### 时间复杂度分析

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

分析的实用方法：

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 常见的时间复杂度

- 多项式量级
    - 常量阶 O(1)
    - 对数阶 O(logn)
    - 线性阶 O(n)
    - 线性对数阶 O(nlogn)
    - 平方阶 O(n2) 立方阶 O(n3)
- 非多项式量级 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。
    - 指数阶 O(2n)
    - 阶乘阶 O(n!)

### 空间复杂度分析

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。注意说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

### 最好情况时间复杂度

最好情况时间复杂度（best case time complexity）就是，在最理想的情况下，执行这段代码的时间复杂度。

### 最坏情况时间复杂度

最坏情况时间复杂度（worst case time complexity）就是，在最糟糕的情况下，执行这段代码的时间复杂度。

### 平均情况时间复杂度

平均情况时间复杂度（average case time complexity）把每种情况发生的概率也考虑进去，每种情况操作的耗时乘以其发生的概率，这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

### 均摊时间复杂度

均摊时间复杂度（amortized time complexity）就是一种特殊的平均时间复杂度，对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

## 🔢 数组

### 定义

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

第一是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

### 低效的插入

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。平均情况时间复杂度为 (1 + 2 + … n) / n = O(n)。

如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。

### 低效的删除

跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

## 🔗 链表

### 定义

数组需要一块连续的内存空间来存储，对内存的要求比较高，而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。

### 测试用例

- [链表包含多个结点](Google_tests/LinkList/NormalLinkListTest.cpp)
- [链表只包含两个结点](Google_tests/LinkList/TwoNodesLinkListTest.cpp)
- [链表只包含一个结点](Google_tests/LinkList/OneNodeLinkListTest.cpp)
- [链表为空](Google_tests/LinkList/EmptyLinkListTest.cpp)

### 基本的增删查

- 对于单向链表，增加和删除都要先找到前驱节点，只能一个个地查找，所以为 O(n)。
- 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。
- [某个指定结点前面插入一个结点：双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。](LinkList/link_list_append_node.cpp)
- [删除给定指针指向的结点：因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了。](LinkList/link_list_remove_node.cpp)

### 增删时，考虑被操作的节点在头部、中间和尾部的情况

- [两个有序（从小到大）单链表，构造一条新链表，包含同时出现在两个链表的节点](LinkList/intersect_two_sorted_link_list.cpp)
- [给定的一个节点指针，在 O(1) 时间内，删除链表节点](LinkList/link_list_remove_node.cpp)
- [在一个排序的链表中删除重复节点](LinkList/link_list_remove_node.cpp)
- [反转链表](LinkList/reverse_link_list.cpp)
- [合并两个排序的链表](LinkList/merge_link_list.cpp)

### 查询时，考虑多个指向不同位置的指针：快慢指针，相隔一定距离的指针

- [从尾到头打印链表](LinkList/print_link_list_reverse.cpp)
- [从链表中找出中间的节点](LinkList/find_middle_node_of_link_list.cpp)
- [从链表中找出倒数第 k 个节点，如 1、2、3、4、5、6，倒数第 3 个节点是 4，删除链表倒数第 n 个结点思路和这个相同](LinkList/find_kth_to_tail_of_link_list.cpp)
- [从链表中找出环的入口节点（含链表中环的检测的步骤）](LinkList/entry_node_of_loop_link_list.cpp)
- [两个链表的第一个公共节点](LinkList/find_first_common_node_of_link_list.cpp)
- [单向链表存储的字符串，判断其是否是回文字符串](LinkList/check_palindromic_string_in_link_list.cpp)

### 链表来实现缓存淘汰策略

- [先进先出策略 FIFO（First In，First Out）](LinkList/find_node_of_cache_in_link_list.cpp)：链表实现的队列；访问数据时，已经缓存的数据，直接返回；没有缓存的数据，缓存未满，新数据直接添加到链表的尾部；缓存已经满，则删除链表头节点，新数据再添加到链表的尾部。
- [最少使用策略 LFU（Least Frequently Used）](LinkList/find_node_of_cache_in_link_list.cpp)：链表按访问次数排序；访问数据时，已经缓存的数据，次数加一，再排序；没有缓存的数据，缓存未满，新数据直接添加到链表的尾部；缓存已经满，则删除链表尾节点，新数据再添加到链表的尾部。
- [最近最少使用策略 LRU（Least Recently Used）](LinkList/find_node_of_cache_in_link_list.cpp)：链表按最近访问时间排序；访问数据时，已经缓存的数据，移动到链表头部；没有缓存的数据，缓存未满，新数据直接插入到链表的头部；缓存已经满，则删除链表尾节点，新数据再插入到链表的头部。

## 🚦 栈和队列

### 栈的定义

当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

### 栈的应用

- 栈在函数调用中的应用：操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。
- 栈在表达式求值中的应用：比如：34+13*9+44-12/3。对于这个四则运算，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。
- 栈在括号匹配中的应用：{[] ()[{}]} 或 [{()}([])] 等都为合法格式，而 {[}()] 或 [({)] 为不合法的格式。用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。
- 实现浏览器的前进、后退功能：使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。

### 队列的定义

入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。

### 队列的应用

- 阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。
- 实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

### 数据插入和删除的特性

- [顺序栈：用数组实现的栈](StackAndQueue/stack.cpp) ，注意空和满的情况；支持动态扩容的顺序栈，入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)，均摊时间复杂度是 O(1)
- [链式栈：用链表实现的栈](StackAndQueue/stack.cpp) ，注意空的情况，最好用双向链表
- [包含 min 函数的栈，输出栈中的最小值](StackAndQueue/stack.cpp) 
- [输入两个整数序列，第一个序列表示栈的压入顺序，判断第二个序列是否为该栈的弹出顺序](StackAndQueue/is_pop_order_of_stack.cpp) 
- [顺序队列：用数组实现的队列](StackAndQueue/queue.cpp)，注意空和满的情况，入队操作可能需要数据移动
- [链式队列：用链表实现的队列](StackAndQueue/queue.cpp)，注意空的情况
- [循环队列：用数组实现的循环队列](StackAndQueue/queue.cpp)，注意空和满的情况，空一个位置不存储数据
- [两个栈实现队列](StackAndQueue/queue.cpp) 

## 🌲 二叉树 Binary Tree

### 定义

#### 树的路径

从树的根节点开始往下一直到叶节点所经过的节点形成一条路径

#### 树的深度

最长路径的长度为树的深度

#### 二叉树

在二叉树中每个节点最多只能有两个节点

#### 二叉搜索树 Binary Search Tree (BST)

左子节点总是小于或等于根节点，而右子节点总是大于或等于根节点，平均在 O(logn) 的时间内根据数值在 BST 中找到一个节点。

### 测试用例

- [完全二叉树](Google_tests/BinaryTree/CompleteBinaryTreeTest.cpp)，[完全二叉搜索树](Google_tests/BinaryTree/CompleteBSTTest.cpp)
- [非完全二叉树](Google_tests/BinaryTree/NonCompleteBinaryTreeTest.cpp)，[非完全二叉搜索树](Google_tests/BinaryTree/NonCompleteBSTTest.cpp)
- [只有左节点的二叉树](Google_tests/BinaryTree/OnlyLeftNodeBinaryTreeTest.cpp)，[只有左节点的二叉搜索树](Google_tests/BinaryTree/OnlyLeftNodeBSTTest.cpp)
- [只有右节点的二叉树](Google_tests/BinaryTree/OnlyRightNodeBinaryTreeTest.cpp)，[只有右节点的二叉搜索树](Google_tests/BinaryTree/OnlyRightNodeBSTTest.cpp)
- [只有一个节点的二叉树](Google_tests/BinaryTree/OneNodeBinaryTreeTest.cpp)
- [空的二叉树](Google_tests/BinaryTree/EmptyBinaryTreeTest.cpp)

### 三种基本遍历

掌握前序遍历、中序遍历、后序遍历，命名的方式是操作子树根节点相对于遍历其左右子树的顺序。

- [前序遍历](BinaryTree/binary_tree.cpp)
- [中序遍历](BinaryTree/binary_tree.cpp)
- [后序遍历](BinaryTree/binary_tree.cpp)

### 前序遍历结果的特点

第一个数字是树的根节点的值，后面的数字可以分为两部分，第一部分是左子树节点的值，如果是 BST，它们都比根节点的值小，
第一部分是右子树节点的值，如果是 BST，它们都比根节点的值大。

- [输入二叉树的前序遍历和中序遍历的结果，结果中不含重复数字，重建此二叉树](BinaryTree/construct_binary_tree_with_preorder_inorder_walk_result.cpp)
- [输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构](BinaryTree/binary_tree_contain_sub_tree.cpp)
- [二叉树的镜像](BinaryTree/mirror_binary_tree.cpp)
- [对称的二叉树](BinaryTree/binary_tree_is_symmetrical.cpp)
- [序列化和反序列化二叉树](BinaryTree/serialize_binary_tree.cpp)

### 中序遍历结果的特点

根节点的值在中间，剩下的数字可以分为前后两部分，前面部分是左子树节点的值，如果是 BST，它们都比根节点的值小，后面部分是右子树节点的值，如果是 BST，它们都比根节点的值大。

- [查找二叉搜索树的第 k 大节点](BinaryTree/find_kth_node_in_bst.cpp)
- [输入一个棵二叉搜索树，将其转换成一个排序的双向链表，不能创建任何新的节点，只能调整树中节点指针的指向](BinaryTree/bst_to_link_list.cpp)
- [找出二叉树中一个节点的中序遍历序列的下一个节点，树中的节点还有一个指向父节点的指针](BinaryTree/get_binary_tree_inorder_walk_next.cpp)

### 后序遍历结果的特点

最后一个数字是数的根节点的值，前面的数字可以分为两部分，第一部分是左子树节点的值，如果是 BST，它们都比根节点的值小，
第一部分是右子树节点的值，如果是 BST，它们都比根节点的值大。

- [输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果](BinaryTree/is_postorder_sequence_of_bst.cpp)
- [二叉树的深度](BinaryTree/binary_tree_depth.cpp)
- [平衡二叉树，任意节点的左、右子树的深度相差不超过 1](BinaryTree/binary_tree_is_balance.cpp)

### 利用队列或栈作为树的辅助

- [从上到下打印二叉树](BinaryTree/top_to_bottom_binary_tree_walk.cpp)
- [分行从上到下打印二叉树](BinaryTree/top_to_bottom_binary_tree_walk.cpp)
- [之字形从上到下打印二叉树](BinaryTree/top_to_bottom_binary_tree_walk.cpp)
- [输入一颗二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径](BinaryTree/find_summary_path_in_binary_tree.cpp)

### 树中两个节点的最低公共祖先

- 二叉搜索树：从树的根节点开始和两个输入的节点进行比较，如果当前节点的值比两个节点的值都大，那么最低的共同父节点一定在当前节点的左子树中，于是下一步遍历当前节点的左子节点，如果当前节点的值比两个节点的值都小，那么最低的共同父节点一定在当前节点的右子树中，于是下一步遍历当前节点的右子节点，这样，在树中从上到下找到的第一个在两个输入节点的值之间的节点就是最低的公共祖先。
- 节点带有父节点的树：从树的每个叶节点开始都有一个由指针 parent 串起来的链表，这些链表的尾指针都是树的根节点，两个节点位于两个链表上，它们的最低公共祖先刚好就是这两个链表的一个公共节点。
- [普通树：用两个链表分别保存从根节点到输入的两个节点的路径，把问题转换成两个链表的最后公共节点。](Tree/get_tree_last_common_parent.cpp)

## 排序
- [冒泡排序](sort.cpp#L23)
- [插入排序](sort.cpp#L50)
- [快速排序](sort.cpp#L87)
- [归并排序](sort.cpp#L138)

## 字符串
- [字符串转数字: 10 进制](data_structure_string.cpp#L52)
- [字符串转数字: 26 进制的大写字母](data_structure_string.cpp#L57)
- [翻转字符串，翻转单词，左旋转字符串](data_structure_string.cpp#L62)

## 时间效率

用空间换时间的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。

- [整数数组中查找最长递增序列](time_efficiency.cpp#L13)
